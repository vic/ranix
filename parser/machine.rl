// compile-command: "ragel -Z -G2 machine.rl"

/* C port of the Ragel lexer (ported from legacy Go). This file is pure C and
   uses the helpers declared in parser/lexer.h. */

#include <stdlib.h>
#include <string.h>
#include "lexer.h"
#include "tokens.h"

#define maxstack 64

%%{

machine expr;

prepush { /* replaced nostack-return to return non-zero error */ }

Space    = [ \t\r\n]+;
Comment1 = "#" [^\r\n]*;
Comment2 = "/*" any* :>> "*/";
URI      = [a-zA-Z] [a-zA-Z0-9.+\-]* ":" [a-zA-Z0-9%/?:@&=+$,_.!~*'\-]+;
Path     = [a-zA-Z0-9._+\-]* ([/] [a-zA-Z0-9._+\-]+)+ [/]?;
HPath    = "~" ([/] [a-zA-Z0-9._+\-]+)+ [/]?;
SPath    = "<" [a-zA-Z0-9._+\-]+ ([/] [a-zA-Z0-9._+\-]+)* ">";
ID       = [a-zA-Z0-9_] [a-zA-Z0-9_'\-]*;
Float    = (([1-9] [0-9]* [.] [0-9]*) | (0? [.] [0-9]+)) ([Ee] [+\-]? [0-9]+)?;
Int      = [0-9]+;


qstring := |*

[\"] => { if (!tokleave('"', r)) return 1; fret; };
"${" => { tokenter(INTERP, '}', r); fcall expr; };
( [^$"\\] | /[$][^{"]/ | /\\./ )+ => { tok(TEXT, r); add_lines(r, ts, te); };
"$" => { tok(TEXT, r); };

*|;


istring := |*

"''" => { if (!tokleave(II, r)) return 1; fret; };
"${" => { tokenter(INTERP, '}', r); fcall expr; };
( [^'$] | "'''" | "''$" | /''\\./ | /'[^'$]/ | /[$][^{']/ )+ => { tok(TEXT, r); add_lines(r, ts, te); };
['$] => { tok(TEXT, r); };

*|;


expr := |*

"assert"  => { tok(ASSERT_, r); };
"else"    => { tok(ELSE_, r); };
"if"      => { tok(IF_, r); };
"in"      => { tok(IN, r); };
"inherit" => { tok(INHERIT, r); };
"let"     => { tok(LET, r); };
"or"      => { tok(OR_, r); };
"rec"     => { tok(REC, r); };
"then"    => { tok(THEN, r); };
"with"    => { tok(WITH, r); };

[ \t\r]+;
"\n"     => { add_line(r, ts); };
Comment1 => { tokcomment(COMMENT, r); };
Comment2 => { tokcomment(COMMENT, r); add_lines(r, ts, te); };
URI      => { tok(URI, r); };
Path     => { tok(PATH, r); };
HPath    => { tok(PATH, r); };
SPath    => { tok(PATH, r); };
Float    => { tok(FLOAT, r); };
Int      => { tok(INT_, r); };
ID       => { tok(ID, r); };

"..." => { tok(ELLIPSIS, r); };
"->"  => { tok(IMPL, r); };
"||"  => { tok(OR, r); };
"&&"  => { tok(AND, r); };
"=="  => { tok(EQ, r); };
"!="  => { tok(NEQ, r); };
"<="  => { tok(LEQ, r); };
">="  => { tok(GEQ, r); };
"//"  => { tok(UPDATE, r); };
"++"  => { tok(CONCAT, r); };

[\"]  => { tokenter('"', '"', r); fcall qstring; };
"''" => { tokenter(II, II, r); fcall istring;  };

"${"   => { tokenter(INTERP, '}', r); fcall expr; };
"(" => { tokenter('(', ')', r); fcall expr; };
"[" => { tokenter('[', ']', r); fcall expr; };
"{" => { tokenter('{', '}', r); fcall expr; };
[}\])] => { if (!tokleave((int)(*ts), r)) return 1; fret; };

[@:] => { if (!tokarg(r)) return 1; };

any => { tok((int)(*ts), r); };

*|;

}%%

%% write data;

/* C lexical wrapper generated by Ragel */

int lexData(const char *data, int len, LexResult *r) {
    int cs = 0, act = 0;
    const char *p = data;
    const char *pe = data + len;
    const char *eof = pe;
    const char *ts = NULL, *te = NULL;
    int top = 0;
    int stack[maxstack];
    Backrefs backrefs = { NULL, 0, 0 };

    /* helper to set an error message (allocated) */
    void set_err(const char *msg) {
        if (r->errmsg) { free(r->errmsg); r->errmsg = NULL; }
        size_t m = strlen(msg) + 1;
        r->errmsg = malloc(m);
        if (r->errmsg) memcpy(r->errmsg, msg, m);
    }

    /* nostack check used by actions; returns 1 on error (and sets r->errmsg) */
    #define nostack() ( (top) >= maxstack ? (set_err("exceeds recursion limit"), 1) : 0 )

    /* append or set r->data */
    if (r->data == NULL) {
        r->data = malloc(len);
        if (!r->data) { set_err("out of memory"); return 1; }
        memcpy(r->data, data, len);
        r->len = len;
    } else {
        char *nd = realloc(r->data, r->len + len);
        if (!nd) { set_err("out of memory"); return 1; }
        r->data = nd;
        memcpy(r->data + r->len, data, len);
        r->len += len;
    }

%% write init;
    (void)expr_first_final; (void)expr_error; (void)expr_en_qstring; (void)expr_en_istring; (void)expr_en_expr;

    /* Ragel exec block will use the macros (tok, tokenter, tokleave, tokarg, add_lines, add_line)
       declared in parser/lexer.h and expect local variables ts, te, top, backrefs, data, p, pe, cs. */


%% write exec;

    if (p != eof) {
        set_err("precedes the token that failed to lex");
        return 1;
    } else if (backrefs_len(&backrefs) != 0) {
        /* unterminated construct */
        set_err("is not terminated");
        free(backrefs.v);
        return 1;
    }
    free(backrefs.v);
    return 0;
}
