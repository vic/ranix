#ifndef PARSER_LEXER_H
#define PARSER_LEXER_H

#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
    int Sym;
    int Pos;
    int End;
    int Prev;
} lexerToken;

typedef struct {
    char *filename;    /* owned */
    char *data;        /* owned */
    int len;

    lexerToken *tokens;
    size_t ntokens;
    size_t ctokens;

    lexerToken *comments;
    size_t ncomments;
    size_t ccomments;

    int *lines; /* offsets of line starts */
    size_t nlines;
    size_t clines;

    char *errmsg;
} LexResult;

/* Backrefs: stack of pairs (index, fin) */
typedef struct {
    int *v; /* flat array of pairs */
    size_t n;
    size_t c;
} Backrefs;

/* Create/destroy */
LexResult *newLexResult(const char *path, int size);
void freeLexResult(LexResult *r);

/* Helper to convert sym to string (optional, implemented in parser) */
const char *symString(int sym);

/* Ragel-generated lexer entry point (implemented after running ragel on machine.rl)
   Signature may be adjusted when you convert the Ragel wrapper to C. */
int lexData(const char *data, int len, LexResult *r);

/* Low-level push helpers used by macros (defined in lexer_helper.c) */
void lexresult_push_token(LexResult *r, int sym, int ts, int te);
void lexresult_push_comment(LexResult *r, int sym, int ts, int te);

/* Backrefs helpers */
void backrefs_push(Backrefs *s, int i, int fin);
int backrefs_pop(Backrefs *s, int *i, int *fin);
size_t backrefs_len(const Backrefs *s);
void backrefs_free(Backrefs *s);

/* Implementations called by the Ragel actions (prototypes) */
void tokenter_impl(int sym, int fin, LexResult *r, Backrefs *backrefs, int ts, int te);
int tokleave_impl(int sym, LexResult *r, Backrefs *backrefs, int *top, int ts, int te);
int tokarg_impl(LexResult *r, int ts, int te);
void add_lines_impl(LexResult *r, int ts, int te);
void add_line_impl(LexResult *r, int ts);

/* Scanner adapter helpers (implemented in lexer_adapter.c) */
void *create_scanner(const char *buf, int len, const char *filename);
void free_scanner(void *scanner);
LexResult *scanner_lexresult(void *scanner);

/* Convenience macros used inside the Ragel actions. These expect the
   local variables `ts`, `te`, `top` and `backrefs` to be available in
   the lexical function generated by Ragel (this mirrors the original
   Go code's closures). ts and te are pointers into the input buffer;
   compute integer offsets relative to `data`. */
#define tok(sym, r)        lexresult_push_token((r), (sym), (int)((ts) - (data)), (int)((te) - (data)))
#define tokcomment(sym, r) lexresult_push_comment((r), (sym), (int)((ts) - (data)), (int)((te) - (data)))
#define tokenter(sym,fin,r) tokenter_impl((sym),(fin),(r), &backrefs, (int)((ts) - (data)), (int)((te) - (data)))
#define tokleave(sym,r)    tokleave_impl((sym),(r), &backrefs, &top, (int)((ts) - (data)), (int)((te) - (data)))
#define tokarg(r)          tokarg_impl((r), (int)((ts) - (data)), (int)((te) - (data)))
#define add_lines(r,ts_,te_) add_lines_impl((r),(int)((ts_) - (data)),(int)((te_) - (data)))
#define add_line(r,ts_)    add_line_impl((r),(int)((ts_) - (data)))

#ifdef __cplusplus
}
#endif

#endif /* PARSER_LEXER_H */
